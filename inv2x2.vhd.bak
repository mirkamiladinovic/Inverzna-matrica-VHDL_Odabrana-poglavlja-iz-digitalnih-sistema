library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.fixed_pkg.all;

use work.matrix_pkg.all;

entity inv2x2 is
  port (
    clk   : in  std_logic;
    rst   : in  std_logic;
    start : in  std_logic;
    m_in  : in  mat2_t;
    done  : out std_logic;
    m_inv : out mat2_t
  );
end entity;

architecture rtl of inv2x2 is
  type state_t is (IDLE, DET, INIT_RECIP, NR1, NR2, OUT);
  signal st : state_t := IDLE;

  signal a,b,c,d : q_t;
  signal det     : q_t;

  -- širi internal za NR
  subtype qwide_t is sfixed(7 downto -24);
  signal x0, x1, x2 : qwide_t;

  function q_to_w(x : q_t) return qwide_t is
  begin
    return resize(x, qwide_t'high, qwide_t'low);
  end;

begin
  process(clk)
    variable t1, t2 : qwide_t;
    variable two    : qwide_t;
  begin
    if rising_edge(clk) then
      if rst='1' then
        st   <= IDLE;
        done <= '0';
      else
        done <= '0';
        two := to_sfixed(2.0, qwide_t'high, qwide_t'low);

        case st is
          when IDLE =>
            if start='1' then
              a <= m_in(0,0); b <= m_in(0,1);
              c <= m_in(1,0); d <= m_in(1,1);
              st <= DET;
            end if;

          when DET =>
            -- det = a*d - b*c
            t1 := q_to_w(a) * q_to_w(d);
            t2 := q_to_w(b) * q_to_w(c);
            det <= resize(t1 - t2, q_t'high, q_t'low);
            st  <= INIT_RECIP;

          when INIT_RECIP =>
            -- početna aproksimacija x0: grubo 1.0 (za seminarski).
            -- U praksi: normalizacija + LUT.
            x0 <= to_sfixed(1.0, qwide_t'high, qwide_t'low);
            st <= NR1;

          when NR1 =>
            -- x1 = x0*(2 - det*x0)
            t1 := q_to_w(det) * x0;
            x1 <= x0 * (two - t1);
            st <= NR2;

          when NR2 =>
            -- x2 = x1*(2 - det*x1)
            t1 := q_to_w(det) * x1;
            x2 <= x1 * (two - t1);
            st <= OUT;

          when OUT =>
            -- inv = (1/det)*[d -b; -c a]
            m_inv(0,0) <= resize(q_to_w(d) * x2, q_t'high, q_t'low);
            m_inv(0,1) <= resize(q_to_w(-b) * x2, q_t'high, q_t'low);
            m_inv(1,0) <= resize(q_to_w(-c) * x2, q_t'high, q_t'low);
            m_inv(1,1) <= resize(q_to_w(a) * x2, q_t'high, q_t'low);
            done <= '1';
            st   <= IDLE;

        end case;
      end if;
    end if;
  end process;
end architecture;